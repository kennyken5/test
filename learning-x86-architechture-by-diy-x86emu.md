# 自作エミュレータで学ぶＸ８６アーキテクチャ

## まえがきから

本筋とは関係なかったが、ＭＤ５０のルールの４１、
最初の行は見出しレベル１でなければならない
が、指摘されてしまった。

以上、あとから挿入したもの。

書籍自作エミュレータで学ぶＸ８６アーキテクチャを読む

全198頁
全４章
chap.1 Ｃ言語とアセンブリ言語（と機械語との諸関係とは？）
chap.2 ポインタとアセンブリ言語（：Ｃのポインタをアセンブリ言語から眺める）
chap.3 ＣＰＵがプログラムを実行する仕組み（：本書の中心をなす。ＨＤＤに書かれたプログラムがどう読み込まれるか）
chap.4 BIOSの仕組みと実機起動

導入

問う。エミュレータ、コンピュータ分野のそれとは何か？
答える。まずそれはソフトウェアのひとつである。
他のハードウェアやソフトウェアを模倣する別のソフトウェアである。
模倣でなけれなエミュではなない。
例えばオリジナルのコピーはエミュではない。

問う。本書の扱うエミュはどのようなものか？
答える。まず、本書が扱わない種類のエミュを説く。
例えば、VirtualBox。いま主流の仮想化方式によるエミュ。
現実ハードウェアのCPUを間借りするものであり、
CPUの動作をソフトウェアでエミュレートするものではないため、
このＣＰＵ間借り方式では、
x86_CPUの上でARM_CPU向けのソフトウェアを動かすことはできない。
しかし、同じx86_CPU向けのソフトウェアであれは高速に動かせる。
ＣＰＵ間借り方式は速度が出せるため実用には適しているが、エミュの学習には不向きである。
したがって、本書が扱うのはＣＰＵ動作をソフトウェアで模倣し、
その上で別のソフトウェアを実行委するＣＰＵエミュである。
ｍ２のｍ68kもそうだね。左はモトローラＣＰＵであり、
本書が扱うのはインテルＣＰＵ。のはず。

問う。ＣＰＵエミュを作る意義は何か？
答える。まず、現実にＣＰＵ制作するのは電子工作である。エミュならはんだごては不要である。
次に、エミュレータ制作を通じてコンピュータの内側を学習できる。
ひとつ。コンピュータを構成する各要素を理解。CPU記憶装置入出力装置など。
ひとつ。機械語とアセンブリ言語の理解。
ひとつ。エミュ制作のためのプログラミング言語の理解。
これらは個別に学ぶこともできるが、ＣＰＵエミュを作るならひとセットで行ける。
コンピュータの低水準な部分を一通りさらえるのである。

問う。本書が扱うＣＰＵの種類は何か？
答える。インテルの８０３８６である。いまのインテルコアの直系祖先であり、
その採用するｘ８６アーキテクチャは、いまのいんてるこあＣＰＵに上位互換。

８ビットである８０８０を１６ビットに拡張したのが８０８６である。
８０８６はＮＥＣのＰＣ９８に採用された。
姉妹品の８０８８はＩＢＭＰＣに採用された。
８０８６の後継が、８０２８６や８０３８６である。
上３つを総称してｘ８６アーキテクチャと呼ぶ。

１９８５年に８０３８６が発売された。ｘ８６アーキテクチャで初の３２ビットＣＰＵである。
３２ビットなので、扱えるメモリ空間は４ＧＢに拡張された。
２００４年にペンティアム４の第３世代インテル６４アーキテクチャまで
パソコン用ＣＰＵデファクトスタンダードとなった。
（テル６４は、ｘ８６－６４とかＡＭＤ６４と呼ばれる）

## chap.1 Ｃ言語とアセンブリ言語
はじめに／言語ｃで書かれたプログラムがアセンブリ言語で書かれたプログラムに変換される様を説明する。
また、アセンブリ言語と機械語の関係性についても説明する。

### １－１：Ｃ言語から機械語へ

我々がふつうに書くＣ言語プログラムのファイル形式はテキストファイルである。
ＣＰＵはファイルをバイナリファイルをして読む。

ＣＰＵが解釈できるのはもっと原始的な命令、つまり機械語の列だけを解釈できる。
反対に言うと、ＣＰＵが解釈できる命令こそ機械語と呼べるものである。

基板上の電子回路では、電圧の高い低いで０か１が記録されている（ふつう1.35Vと０V）。
同様に、ＨＤでは磁石のＳ極Ｎ極で、ＤＲＡＭではコンデンサに電荷が溜まっているか否かで記録されている。

### １－２：機械語とアセンブリ言語

ひとにとって機械語は非常に読みづらい。その困難を解決すべく、アセンブリ言語が作られた。
アセンブリ言語は機械語と一対一対応しているが、機械語よりも多少読みやすくなっている。
（その中間にASCIIコードがあるような気がする。コードにはASCIIコードと異なり非８ビットのもの、例えばテレタイプのものなどもあるが）

リスト１．１ Ｃ言語のプログラム
void func(void) {
    int val = 0;
    val++;
}

リスト１．2　上を機械語に変換したもの
55,89,e5,83,ec,10,c7,45,fc,00,00,00,00,ff,45,fc,c9,c3

リスト１．4　上にアセンブラ言語に変換したものを加えたもの
push    ebp 55,
move    ebp,    esp 89,e5,
sub     esp,byte +0x10  83,ec,10,
mov    dword [ebp-0x4],0x0  c7,45,fc,00,00,00,00,
inc      dword [ebp-0x4] ff,45,fc,
leave        c9,
ret           c3,

前述したように、アセンブラ言語で書いたプログラムの文は機械語と一対一対応する。
しかし、Ｃ言語のプログラムは機械語と一対一対応しない。以下、例として、int型変数valに対して、

val++;

または、

val　＋＝　1;

と書いたとき、これをＣにコンパイルすると、

inc [ebp-4]

となるか、

add[epb-4],1

となるか、それとも全く異なるものとなるかもしれない。
実行されていること自体は同じであり、変数valに1を加える、である。

ことば：
Ｃ言語プログラムを機械語に変換することをコンパイルと言う。
アセンブリ言語プログラムを機械語に変換することはアセンブルと呼び、コンパイルと呼ばない。

最後にアセンブルの例外について記す。

ひとつの機械語命令が複数のアセンブリ言語命令に対応する例。
0x90 は nop と xchg eax,eax に対応する。
nop は no operation の意味で、何もせず時間を消費する命令である。
xchg eax,eax は、 eax と eax を入れ替える命令である。
xchgはexchange、eaxはレジスタである。
結果的にnopと同じ内容となる。

複数の機械語命令がひとつのアセンブリ言語命令に対応する例。
機械語の「0x40」と「0xff 0xc0」とがアセンブラ言語の「inc eax」に対応する。
両者はレジスタ名の指定のやり方が異なる。

オペコード「0x40」はレジスタeaxの指定を含むが、
オペコード「0xff」はレジスタeaxの指定を含まず、単にinc命令であるだけなので、レジスタの指定が必要である。
後続の1バイト0Xc0（の中でも、6-7ビット目11および0-2ビット目000）により、inc命令の操作対象がeaxであることを示す。
（実は0xffはincまたはdecを表す。そのどちらかかの指定は、ModR/Mバイト0xc0の3-5ビット目で決まる。後述）

おまけ
x86はCISCアーキテクチャであり、各命令のバイト数が異なっていたり、高度な計算をまとめて行う命令があったりするが、
RISCアーキテクチャの特徴を持つARMでは、多くの命令が4バイトの固定長である。

原著の17ページには、リスト１．１ Ｃ言語のプログラムをARM用gccでコンパイルした例が載っている。

00000000 <func>:
0:e52db004　　　Push{fp};(str fp,[sp,#-4]!)
以下、略

### １－３：機械語に飛び込む
演習。用意されたサンプルファイルを用いて逆アセンブルを行う。

Ｃ言語で書かれたプログラムのテキストファイル「casm-c-sample.c」の内容は以下。

    void func(void) {
    int val = 0;
    val++;
    }

　
このファイルをgccを用いてコンパイルして機械語の実行ファイルに変換し、
さらにそれを逆アセンブルする（命令ndiasemによって）。

> ndisasm -b 32 casm-c-sample.bin

ここで「-b 32」とし、32ビットモードのプログラムと指定する。
この指定を抜いて実行すると、16ビットモードで解釈されてしまう。

### １－４：アセンブリ言語を少し詳しく

アセの文法
オペコード オペランド1,オペランド2
オペコとオペラを合わせたものをニーモックと呼ぶ。
Ｃ言語に対応させると、オペコは関数名、オペラは実引数、ニーモは適当な対応物なし。

### １－５：基本のmov命令

move 移動先,移動元

先に対し、元のデータをコピーする。一度にmovできるデータは1,2,4バイトに限られる。

1.mov ebd,esp

レジスタebdの中身をレジスタespへmov（コピー）する。
この２つのレジスタは任意の32ビットの値を記録する。

espはスタックポインタ。常にスタックの最新の読み書き位置を保持する。
ここではスタックとはローカル変数を置くためのデータ領域と理解せよ。

2.mov dword [ebp-0x4],0x0

コピー元が0x0で、これは番地ではなく即値またはリテラルと呼び、この場合は数値0である。
コピー先がdword [ebp-0x4]である。

ebp-0x4はメモリ番地
[]とは囲みの内側が数値ではなくメモリ番地を意味づけするためのもの
dwordは領域の大きさを指定するもの(32ビットである)

各メモリ番地には１バイト＝８ビットのデータが記憶できる。

なお、ここで示される変数valの位置[ebp-0x4]とはＣの規格によるものではなく、今回のコンパイルでたまたま選ばれただけ。

アセンブリ言語では、ある領域を示すために２種類の情報を要する。先頭のメモリ番地とその領域の大きさである。

### １－６：インクリメント専用のinc命令

inc インクリメント対象

例のプログラムでは、

inc dword[ebp-0x4]

となっている。変数valに1だけ加算する。

さて、1-2で次のように書いた。

> 機械語の「0x40」と「0xff 0xc0」とがアセンブラ言語の「inc eax」に対応する。
> inc      dword [ebp-0x4] ff,45,fc,

アセンブリ言語による「inc dword [ebp-0x4]」を機械語にすると「ff,45,fc」と変換されている。

また、1-5での説明から、機械語45,fcは「ebp-0x4が」にあたると分かる。
なので、機械語のffがインクリとなる。

機械語命令の構成について述べる。

【inc dword [ebp-0x4] 】こと【ff,45,fc】は、

　　プレフィクス　0～4バイト
ff　　オペコード　1,2,3バイト
45　ModR/M　0,1バイト
　　SIB　　0,1バイト
fc　ディスプレイスメント　0,1,2,4バイト
　　イミディエイト　　0,1,2,4バイト

と図示できる。

オペコードffはその命令がinc命令あるいはdec命令であることを示す。
ModR/Mはメモリ領域の一の決め方（位置自体でなく、位置の決め方）を指示するもので、
ここでの45とは「epb+8ビットディスプレイスメント」で示される番地のメモリ領域を表す。
最後のfcはModR/Mの8ビットディスプレイスメントを示す。
ディスプレイスメントとは位置の差分のこと。

なお、i386の32ビットモードにおいてはdword指定がデフォルトのである。
ゆえに、機械語にはdword指定に相当する記述はない。
アセンブリ言語ではサイズ指定が必須なので記述されている。

DWORDは4バイト
WORDは2バイト
BYTEは1バイト

修飾子と呼ぶ。

### １－７：16進数入門

（略）

### １－８：2の補数入門

コンピュータ分野では、二進数のとき、負の数を表す際に、「補数」を用いるのがならい。
0d41(＝十進数の四十一）は、0b00101001



## chap.2 ポインタとアセンブリ言語

## chap.3 ＣＰＵがプログラムを実行する仕組み

## chap.4 BIOSの仕組みと実機起動
