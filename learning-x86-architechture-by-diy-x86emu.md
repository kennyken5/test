# 自作エミュレータで学ぶＸ８６アーキテクチャ

## まえがきから

本筋とは関係なかったが、ＭＤ５０のルールの４１、
最初の行は見出しレベル１でなければならない
が、指摘されてしまった。

以上、あとから挿入したもの。

書籍自作エミュレータで学ぶＸ８６アーキテクチャを読む

全198頁
全４章
chap.1 Ｃ言語とアセンブリ言語（と機械語との諸関係とは？）
chap.2 ポインタとアセンブリ言語（：Ｃのポインタをアセンブリ言語から眺める）
chap.3 ＣＰＵがプログラムを実行する仕組み（：本書の中心をなす。ＨＤＤに書かれたプログラムがどう読み込まれるか）
chap.4 BIOSの仕組みと実機起動

導入

問う。エミュレータ、コンピュータ分野のそれとは何か？
答える。まずそれはソフトウェアのひとつである。
他のハードウェアやソフトウェアを模倣する別のソフトウェアである。
模倣でなけれなエミュではなない。
例えばオリジナルのコピーはエミュではない。

問う。本書の扱うエミュはどのようなものか？
答える。まず、本書が扱わない種類のエミュを説く。
例えば、VirtualBox。いま主流の仮想化方式によるエミュ。
現実ハードウェアのCPUを間借りするものであり、
CPUの動作をソフトウェアでエミュレートするものではないため、
このＣＰＵ間借り方式では、
x86_CPUの上でARM_CPU向けのソフトウェアを動かすことはできない。
しかし、同じx86_CPU向けのソフトウェアであれは高速に動かせる。
ＣＰＵ間借り方式は速度が出せるため実用には適しているが、エミュの学習には不向きである。
したがって、本書が扱うのはＣＰＵ動作をソフトウェアで模倣し、
その上で別のソフトウェアを実行委するＣＰＵエミュである。
ｍ２のｍ68kもそうだね。左はモトローラＣＰＵであり、
本書が扱うのはインテルＣＰＵ。のはず。

問う。ＣＰＵエミュを作る意義は何か？
答える。まず、現実にＣＰＵ制作するのは電子工作である。エミュならはんだごては不要である。
次に、エミュレータ制作を通じてコンピュータの内側を学習できる。
ひとつ。コンピュータを構成する各要素を理解。CPU記憶装置入出力装置など。
ひとつ。機械語とアセンブリ言語の理解。
ひとつ。エミュ制作のためのプログラミング言語の理解。
これらは個別に学ぶこともできるが、ＣＰＵエミュを作るならひとセットで行ける。
コンピュータの低水準な部分を一通りさらえるのである。

問う。本書が扱うＣＰＵの種類は何か？
答える。インテルの８０３８６である。いまのインテルコアの直系祖先であり、
その採用するｘ８６アーキテクチャは、いまのいんてるこあＣＰＵに上位互換。

８ビットである８０８０を１６ビットに拡張したのが８０８６である。
８０８６はＮＥＣのＰＣ９８に採用された。
姉妹品の８０８８はＩＢＭＰＣに採用された。
８０８６の後継が、８０２８６や８０３８６である。
上３つを総称してｘ８６アーキテクチャと呼ぶ。

１９８５年に８０３８６が発売された。ｘ８６アーキテクチャで初の３２ビットＣＰＵである。
３２ビットなので、扱えるメモリ空間は４ＧＢに拡張された。
２００４年にペンティアム４の第３世代インテル６４アーキテクチャまで
パソコン用ＣＰＵデファクトスタンダードとなった。
（テル６４は、ｘ８６－６４とかＡＭＤ６４と呼ばれる）

## chap.1 Ｃ言語とアセンブリ言語
はじめに／言語ｃで書かれたプログラムがアセンブリ言語で書かれたプログラムに変換される様を説明する。
また、アセンブリ言語と機械語の関係性についても説明する。

### １－１：Ｃ言語から機械語へ

我々がふつうに書くＣ言語プログラムのファイル形式はテキストファイルである。
ＣＰＵはファイルをバイナリファイルをして読む。

ＣＰＵが解釈できるのはもっと原始的な命令、つまり機械語の列だけを解釈できる。
反対に言うと、ＣＰＵが解釈できる命令こそ機械語と呼べるものである。

基板上の電子回路では、電圧の高い低いで０か１が記録されている（ふつう1.35Vと０V）。
同様に、ＨＤでは磁石のＳ極Ｎ極で、ＤＲＡＭではコンデンサに電荷が溜まっているか否かで記録されている。

### １－２：機械語とアセンブリ言語

ひとにとって機械語は非常に読みづらい。その困難を解決すべく、アセンブリ言語が作られた。
アセンブリ言語は機械語と一対一対応しているが、機械語よりも多少読みやすくなっている。
（その中間にASCIIコードがあるような気がする。コードにはASCIIコードと異なり非８ビットのもの、例えばテレタイプのものなどもあるが）

リスト１．１ Ｃ言語のプログラム
void func(void) {
    int val = 0;
    val++;
}

リスト１．2　上を機械語に変換したもの
55,89,e5,83,ec,10,c7,45,fc,00,00,00,00,ff,45,fc,c9,c3

リスト１．4　上にアセンブラ言語に変換したものを加えたもの
push    ebp 55,
move    ebp,    esp 89,e5,
sub     esp,byte +0x10  83,ec,10,
mov    dword [ebp-0x4],0x0  c7,45,fc,00,00,00,00,
inc      dword [ebp-0x4] ff,45,fc,
leave        c9,
ret           c3,

前述したように、アセンブラ言語で書いたプログラムの文は機械語と一対一対応する。
しかし、Ｃ言語のプログラムは機械語と一対一対応しない。以下、例として、int型変数valに対して、

val++;

または、

val　＋＝　1;

と書いたとき、これをＣにコンパイルすると、

inc [ebp-4]

となるか、

add[epb-4],1

となるか、それとも全く異なるものとなるかもしれない。
実行されていること自体は同じであり、変数valに1を加える、である。

ことば：
Ｃ言語プログラムを機械語に変換することをコンパイルと言う。
アセンブリ言語プログラムを機械語に変換することはアセンブルと呼び、コンパイルと呼ばない。

最後にアセンブルの例外について記す。

ひとつの機械語命令が複数のアセンブリ言語命令に対応する例。
0x90 は nop と xchg eax,eax に対応する。
nop は no operation の意味で、何もせず時間を消費する命令である。
xchg eax,eax は、 eax と eax を入れ替える命令である。
xchgはexchange、eaxはレジスタである。
結果的にnopと同じ内容となる。

複数の機械語命令がひとつのアセンブリ言語命令に対応する例。
機械語の「0x40」と「0xff 0xc0」とがアセンブラ言語の「inc eax」に対応する。
両者はレジスタ名の指定のやり方が異なる。

オペコード「0x40」はレジスタeaxの指定を含むが、
オペコード「0xff」はレジスタeaxの指定を含まず、単にinc命令であるだけなので、レジスタの指定が必要である。
後続の1バイト0Xc0（の中でも、6-7ビット目11および0-2ビット目000）により、inc命令の操作対象がeaxであることを示す。
（実は0xffはincまたはdecを表す。そのどちらかかの指定は、ModR/Mバイト0xc0の3-5ビット目で決まる。後述）

おまけ
x86はCISCアーキテクチャであり、各命令のバイト数が異なっていたり、高度な計算をまとめて行う命令があったりするが、
RISCアーキテクチャの特徴を持つARMでは、多くの命令が4バイトの固定長である。

原著の17ページには、リスト１．１ Ｃ言語のプログラムをARM用gccでコンパイルした例が載っている。

00000000 <func>:
0:e52db004　　　Push{fp};(str fp,[sp,#-4]!)
以下、略

### １－３：機械語に飛び込む
演習。用意されたサンプルファイルを用いて逆アセンブルを行う。

Ｃ言語で書かれたプログラムのテキストファイル「casm-c-sample.c」の内容は以下。

    void func(void) {
    int val = 0;
    val++;
    }

　
このファイルをgccを用いてコンパイルして機械語の実行ファイルに変換し、
さらにそれを逆アセンブルする（命令ndiasemによって）。

> ndisasm -b 32 casm-c-sample.bin

ここで「-b 32」とし、32ビットモードのプログラムと指定する。
この指定を抜いて実行すると、16ビットモードで解釈されてしまう。

### １－４：アセンブリ言語を少し詳しく

アセの文法
オペコード オペランド1,オペランド2
オペコとオペラを合わせたものをニーモックと呼ぶ。
Ｃ言語に対応させると、オペコは関数名、オペラは実引数、ニーモは適当な対応物なし。

### １－５：基本のmov命令

move 移動先,移動元

先に対し、元のデータをコピーする。一度にmovできるデータは1,2,4バイトに限られる。

1.mov ebd,esp

レジスタebdの中身をレジスタespへmov（コピー）する。
この２つのレジスタは任意の32ビットの値を記録する。

espはスタックポインタ。常にスタックの最新の読み書き位置を保持する。
ここではスタックとはローカル変数を置くためのデータ領域と理解せよ。

2.mov dword [ebp-0x4],0x0

コピー元が0x0で、これは番地ではなく即値またはリテラルと呼び、この場合は数値0である。
コピー先がdword [ebp-0x4]である。

ebp-0x4はメモリ番地
[]とは囲みの内側が数値ではなくメモリ番地を意味づけするためのもの
dwordは領域の大きさを指定するもの(32ビットである)

各メモリ番地には１バイト＝８ビットのデータが記憶できる。

なお、ここで示される変数valの位置[ebp-0x4]とはＣの規格によるものではなく、今回のコンパイルでたまたま選ばれただけ。

アセンブリ言語では、ある領域を示すために２種類の情報を要する。先頭のメモリ番地とその領域の大きさである。

### １－６：インクリメント専用のinc命令

inc インクリメント対象

例のプログラムでは、

inc dword[ebp-0x4]

となっている。変数valに1だけ加算する。

さて、1-2で次のように書いた。

> 機械語の「0x40」と「0xff 0xc0」とがアセンブラ言語の「inc eax」に対応する。
> inc      dword [ebp-0x4] ff,45,fc,

アセンブリ言語による「inc dword [ebp-0x4]」を機械語にすると「ff,45,fc」と変換されている。

また、1-5での説明から、機械語45,fcは「ebp-0x4が」にあたると分かる。
なので、機械語のffがインクリとなる。

機械語命令の構成について述べる。

【inc dword [ebp-0x4] 】こと【ff,45,fc】は、

　　プレフィクス　0～4バイト
ff　　オペコード　1,2,3バイト
45　ModR/M　0,1バイト
　　SIB　　0,1バイト
fc　ディスプレイスメント　0,1,2,4バイト
　　イミディエイト　　0,1,2,4バイト

と図示できる。

オペコードffはその命令がinc命令あるいはdec命令であることを示す。
ModR/Mはメモリ領域の一の決め方（位置自体でなく、位置の決め方）を指示するもので、
ここでの45とは「epb+8ビットディスプレイスメント」で示される番地のメモリ領域を表す。
最後のfcはModR/Mの8ビットディスプレイスメントを示す。
ディスプレイスメントとは位置の差分のこと。

なお、i386の32ビットモードにおいてはdword指定がデフォルトのである。
ゆえに、機械語にはdword指定に相当する記述はない。
アセンブリ言語ではサイズ指定が必須なので記述されている。

DWORDは4バイト
WORDは2バイト
BYTEは1バイト

修飾子と呼ぶ。

### １－７：16進数入門

（略）

### １－８：2の補数入門

コンピュータ分野では、二進数のとき、負の数を表す際に、「補数」を用いるのがならい。
0d41(＝十進数デシマルによる四十一）は、0b00101001（＝二進数による十進の四十一）。
0b1,0000,0000マイナス0b0010,1001は0b11010111．これをマイナス４１とする。冒頭の1はマイナスの意味。
当然、この数字は0d215とも読める。
（なお、全ビットを反転して1を加えるという計算だと速い）

cの規格ではこの「２の補数」の使用は必須ではないのだが、実際上ではほとんど100％である。

## chap.2 ポインタとアセンブリ言語

### ２－１：レジスタ

以下のＣ言語のプログラム

int i,sum=0;
for(i=0;i<10;i++){
    sum+=i;
}

0から10未満までの自然数を足し合わせる

ハンドアセンブルすると（一例）、

 mov eax,0 ;;;; int i,sum=0 
 mov ecx,eax ;;;; i=0
 jmp loop_end ;;;; "loop_end"に飛ぶ
loop:
 add eax,ecx ;;;; sum+=i;
 inc ecx ;;;; i++
loop_end:
 cmp ecx,10 ;;;; i<10
 jl loop ;;;　が真なら"loop"に飛ぶ

レジスタecxが変数iに、レジスタeaxが変数sumに、対応する。

レジスタの大きさ、数、名前、役割などはＣＰＵに固有なため、
Ｃ言語プログラムは同じコードを異なるＣＰＵで動かせるが、
アセンブリ言語プログラムはほぼ無理である。



### ２－２：メモリ

386には32ビット幅の汎用レジスタが8つある。
旧a,b,c,d(アキュムレジスタ、ベースレジスタ、カウントレジスタ、データレジスタ)だった、
eax、ebx、ecx、edxの４つと…（eは拡張extend）

インデックスレジスタ
esi ソースインデックス
edi ディスティネーションインデックス

特殊レジスタ
esp スタックポインタ
ebp　ベースポインタ

（以上の8つのレジスタ説明はキクチが他所から引用したので、正しいかどうか不明）

◆

メモリの0x7c00番地から0x7c03番地までの4バイトのデータを、
メモリの0x7a00番地から0x7a03番地までの領域にコピーする。

mov eax,[0x7c00]
mov [0x7a00],eax

あるいは、

mov ebx,0x7a00
mov eax,[ebx+0x200]
mov [ebx],eax

さて、c言語の未resister指定な変数は、
プログラマの視点からはメモリに置かれる。
そのため、未resister指定な変数は、
必ずその変数が置かれたメモリ番地を持つ。

&演算子が適用された変数は、
最適化によって決してレジスタに置かれることは起きない。
なぜならば、レジスタはＣＰＵ内にあるため、
レジスタはメモリ番号を決して持ちえないのである。

また、resister宣言された変数へ&演算子を適用しようとすると、
実際にレジスタに置かれるか否かに関わらず、コンパイルエラーとなる。

◆lea命令

void func(void){
    int val;
    int *ptr=&val;
    *ptr=41;
}

以上のアセンブル結果（ndisasmの出力を修正し、対応するC言語のソースコードを追記）は以下

########;void fund(void){
push ebp
mov ebp,esp
sub esp,16

########; int val;
########; int *ptr=&val;
lea eax,[ebp-8]　　　（１）
mov [ebp-4],eax　　　（２）

########; int *ptr=41;
mov eax,[ebp-4]　　　（３）
mov dword[eax],41　　　（４）
}

leave
ret

pushとleaveは関数の入り口と出口での定型的な処理をするもの。
（１）lea命令により、変数val([ebp-8])の番地がレジスタeaxに格納される。
（２）レジスタeaxの値が変数ptr([ebp-4])に格納される。
（３）変数ptr([ebx-4])の値をレジスタeaxに読み出し、
（４）そのレジスタeaxの値で示される4バイトのメモリ領域に41を書き込む。
こうして最終的に変数val([ebp-8])に41が書き込まれる。

アセンブリ言語の世界では、レジスタは名前で呼び、メモリは番地でその場所を表す。

c言語の世界ではメモリに名前を付ける機能があり、それを「変数」と称する。
ｃ言語の「変数」とは、つまり特定のメモリ番地に“val"のようにひとに分かりやすい名前を付ける。

機械語の世界では、レジスタに名前はなく番号が振られている。
レジスタeaxは0、ecxは1、というふうに。

機械語はレジスタもメモリ番地も数値で指定する。
アセンブリ言語ではレジスタは名前で、メモリ番地は数値で指定する。
Ｃ言語はレジスタは使えず、メモリ番地は名前で指定する

余談。int型のような複数ナイトにまたがる変数に値を格納するとき、
どんなバイトの順序にするかはＣＰＵによって異なる。
本書の扱うintelのＣＰＵは小さい桁が小さい番地に配置される「リトル・エンディアン」。

変数ptrに0x00007bf0という4バイトの値が格納されたとき、
メモリ上では、0xf0、0x7b、0x00、0x00、と並ぶ。

なお、ネット上を流れるデータでは「ビック・エンディアン」に統一することに決まっている。
0x00、0x00、0x7b、0xf0、である。


### ２－３：初めてのエミュレータ

（あとから挿入　本文では、main.cの全文解説は行われていないので、フォルダtolset_p86\emu2.3を見よ


まず、エミュ本体を表す構造体を定義する。
次に、エミュ構造体を生成して初期化し、ファイルから機械語プログラムを読み込む処理を書いてゆく。
そして、エミュの核心である機械語を実行する部分を作ってゆく。

i386の32ビットモード用の機械語プログラムが書かれたファイルを受け取ると、
それを先頭から順に実行してゆくようなものを作る。

リスト2.5：main.c
typedef struct{
    /* 汎用レジスタ  */
    uint32_t registers[REGISTERS_COUNT];

  /* EFLAGSレジスタ  */
   uint32_t eflags;

   /* メモリ（バイト列）  */
   uint8_t memory;

   /* プログラムカウンタ  */
   unit_t eip;
}　Emulator;


エミュ構造体を生成して初期化し、ファイルから機械語プログラムを読み込む処理するもの。
コマンド名はpx86とする。コマンドライン引数に機械語プログラムが格納されたファイルを指定する仕様とした。
そこで、main関数の頭でまずコマンドライン引数がひとつ指定されていることを確認する。
続いてcreate_emuでエミュ構造体を作成して初期化。
最後に機械語のファイルを開き、freadでemu->memoryに読み取る。

リスト２.6：main.c
Emulator* create_emu(size_t size, unin32_t eip, uint32_t esp)
{
    Emulator* emu=malloc(sizeof(Emulator));
    emu->memory=malloc(size);

    /* 汎用レジスタの初期値をすべて0にする */
    memset(emu->registers,0,sizeof(emu->registers));

    /* レジスタの値初期値を指定されたものとする */
    emu->eip=eip;
    emu->resisters[ESP]=esp;

    return emu;   
}

/* エミュレータを破壊する */
void destory_emu(Emulator* emu)
{
    free(emu->memory);
    free(emu);
}

int main(int argc,char* argv[])
{
    FILE*=binary;
    Emulatoer* emu;

    if(argc !=2){
        printf("usage:px86 filename\n");
        return 1;
    }
/* EIPが0、ESPが0X7C00の状態のエミュレータを作る */
emu=create_emu(MEMORY_SIZE,0x0000.0x7c00);

binary=forpen(argv[1],"rb");
if(binary==NULL){
    printf("%sファイルが開けません￥n",argv[1]);
    return１；
}

/*　機械語ファイルを読み込む　最大512バイト　*/
fread(emu->memory,1,0x200,binary);
fclose(binary);

destory_emu(emu);
return　0;
}

main.cのソースコード解説部分はここでパスすることにする。
このエミュに実装した命令は、即値をレジスタに書き込むmovとショートジャンプのjmpのみである。
ゆえに、以下のようなファイルhellowworld.asmのプログラムを起動できる


hellowworld.asm
BIT 32
start:
    mov eax,41
    jmp short start

tolset_p86\pasm-helloworldにある!cons_nt.batを実行せよ。
そして現れるターミナルにて、makeを実行せよ。
すると、helloworld.binが作られる。

次にエミュをビルドする。
tolset_p86\emu2.3の!cons_nt.batを実行せよ。
そして現れるターミナルにて、makeを実行せよ。
すると、px86.exeが作られる。

この状態で、
px86.exe ..\pasm-helloworld\helloworld.bin

レジスタeaxの値が29なら成功　ｏｋ









## chap.3 ＣＰＵがプログラムを実行する仕組み

## chap.4 BIOSの仕組みと実機起動
