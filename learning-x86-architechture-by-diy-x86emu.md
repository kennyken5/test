# 自作エミュレータで学ぶＸ８６アーキテクチャ

## まえがきから

本筋とは関係なかったが、ＭＤ５０のルールの４１、
最初の行は見出しレベル１でなければならない
が、指摘されてしまった。

以上、あとから挿入したもの。

書籍自作エミュレータで学ぶＸ８６アーキテクチャを読む

全198頁
全４章
chap.1 Ｃ言語とアセンブリ言語（と機械語との諸関係とは？）
chap.2 ポインタとアセンブリ言語（：Ｃのポインタをアセンブリ言語から眺める）
chap.3 ＣＰＵがプログラムを実行する仕組み（：本書の中心をなす。ＨＤＤに書かれたプログラムがどう読み込まれるか）
chap.4 BIOSの仕組みと実機起動

導入

問う。エミュレータ、コンピュータ分野のそれとは何か？
答える。まずそれはソフトウェアのひとつである。
他のハードウェアやソフトウェアを模倣する別のソフトウェアである。
模倣でなけれなエミュではなない。
例えばオリジナルのコピーはエミュではない。

問う。本書の扱うエミュはどのようなものか？
答える。まず、本書が扱わない種類のエミュを説く。
例えば、VirtualBox。いま主流の仮想化方式によるエミュ。
現実ハードウェアのCPUを間借りするものであり、
CPUの動作をソフトウェアでエミュレートするものではないため、
このＣＰＵ間借り方式では、
x86_CPUの上でARM_CPU向けのソフトウェアを動かすことはできない。
しかし、同じx86_CPU向けのソフトウェアであれは高速に動かせる。
ＣＰＵ間借り方式は速度が出せるため実用には適しているが、エミュの学習には不向きである。
したがって、本書が扱うのはＣＰＵ動作をソフトウェアで模倣し、
その上で別のソフトウェアを実行委するＣＰＵエミュである。
ｍ２のｍ68kもそうだね。左はモトローラＣＰＵであり、
本書が扱うのはインテルＣＰＵ。のはず。

問う。ＣＰＵエミュを作る意義は何か？
答える。まず、現実にＣＰＵ制作するのは電子工作である。エミュならはんだごては不要である。
次に、エミュレータ制作を通じてコンピュータの内側を学習できる。
ひとつ。コンピュータを構成する各要素を理解。CPU記憶装置入出力装置など。
ひとつ。機械語とアセンブリ言語の理解。
ひとつ。エミュ制作のためのプログラミング言語の理解。
これらは個別に学ぶこともできるが、ＣＰＵエミュを作るならひとセットで行ける。
コンピュータの低水準な部分を一通りさらえるのである。

問う。本書が扱うＣＰＵの種類は何か？
答える。インテルの８０３８６である。いまのインテルコアの直系祖先であり、
その採用するｘ８６アーキテクチャは、いまのいんてるこあＣＰＵに上位互換。

８ビットである８０８０を１６ビットに拡張したのが８０８６である。
８０８６はＮＥＣのＰＣ９８に採用された。
姉妹品の８０８８はＩＢＭＰＣに採用された。
８０８６の後継が、８０２８６や８０３８６である。
上３つを総称してｘ８６アーキテクチャと呼ぶ。

１９８５年に８０３８６が発売された。ｘ８６アーキテクチャで初の３２ビットＣＰＵである。
３２ビットなので、扱えるメモリ空間は４ＧＢに拡張された。
２００４年にペンティアム４の第３世代インテル６４アーキテクチャまで
パソコン用ＣＰＵデファクトスタンダードとなった。
（テル６４は、ｘ８６－６４とかＡＭＤ６４と呼ばれる）

## chap.1 Ｃ言語とアセンブリ言語
はじめに／言語ｃで書かれたプログラムがアセンブリ言語で書かれたプログラムに変換される様を説明する。
また、アセンブリ言語と機械語の関係性についても説明する。

### １－１：Ｃ言語から機械語へ

我々がふつうに書くＣ言語プログラムのファイル形式はテキストファイルである。
ＣＰＵはファイルをバイナリファイルをして読む。

ＣＰＵが解釈できるのはもっと原始的な命令、つまり機械語の列だけを解釈できる。
反対に言うと、ＣＰＵが解釈できる命令こそ機械語と呼べるものである。

基板上の電子回路では、電圧の高い低いで０か１が記録されている（ふつう1.35Vと０V）。
同様に、ＨＤでは磁石のＳ極Ｎ極で、ＤＲＡＭではコンデンサに電荷が溜まっているか否かで記録されている。

### １－２：機械語とアセンブリ言語

ひとにとって機械語は非常に読みづらい。その困難を解決すべく、アセンブリ言語が作られた。
アセンブリ言語は機械語と一対一対応しているが、機械語よりも多少読みやすくなっている。
（その中間にASCIIコードがあるような気がする。コードにはASCIIコードと異なり非８ビットのもの、例えばテレタイプのものなどもあるが）

リスト１．１ Ｃ言語のプログラム
void func(void) {
    int val = 0;
    val++;
}

リスト１．2　上を機械語に変換したもの
55,89,e5,83,ec,10,c7,45,fc,00,00,00,00,ff,45,fc,c9,c3

リスト１．4　上にアセンブラ言語に変換したものを加えたもの
push    ebp 55,
move    ebp,    esp 89,e5,
sub     esp,byte +0x10  83,ec,10,
mov    dword [ebp-0x4],0x0  c7,45,fc,00,00,00,00,
inc      dword [ebp-0x4] ff,45,fc,
leave        c9,
ret           c3,

前述したように、アセンブラ言語で書いたプログラムの文は機械語と一対一対応する。
しかし、Ｃ言語のプログラムは機械語と一対一対応しない。以下、例として、int型変数valに対して、

val++;

または、

val　＋＝　1;

と書いたとき、これをＣにコンパイルすると、

inc [ebp-4]

となるか、

add[epb-4],1

となるか、それとも全く異なるものとなるかもしれない。
実行されていること自体は同じであり、変数valに1を加える、である。

ことば：
Ｃ言語プログラムを機械語に変換することをコンパイルと言う。
アセンブリ言語プログラムを機械語に変換することはアセンブルと呼び、コンパイルと呼ばない。

最後にアセンブルの例外について記す。

ひとつの機械語命令が複数のアセンブリ言語命令に対応する例。
0x90 は nop と xchg eax,eax に対応する。
nop は no operation の意味で、何もせず時間を消費する命令である。
xchg eax,eax は、 eax と eax を入れ替える命令である。
xchgはexchange、eaxはレジスタである。
結果的にnopと同じ内容となる。

複数の機械語命令がひとつのアセンブリ言語命令に対応する例。
機械語の「0x40」と「0xff 0xc0」とがアセンブラ言語の「inc eax」に対応する。
両者はレジスタ名の指定のやり方が異なる。

オペコード「0x40」はレジスタeaxの指定を含むが、
オペコード「0xff」はレジスタeaxの指定を含まず、単にinc命令であるだけなので、レジスタの指定が必要である。
後続の1バイト0Xc0（の中でも、6-7ビット目11および0-2ビット目000）により、inc命令の操作対象がeaxであることを示す。
（実は0xffはincまたはdecを表す。そのどちらかかの指定は、ModR/Mバイト0xc0の3-5ビット目で決まる。後述）

おまけ
x86はCISCアーキテクチャであり、各命令のバイト数が異なっていたり、高度な計算をまとめて行う命令があったりするが、
RISCアーキテクチャの特徴を持つARMでは、多くの命令が4バイトの固定長である。

原著の17ページには、リスト１．１ Ｃ言語のプログラムをARM用gccでコンパイルした例が載っている。

00000000 <func>:
0:e52db004　　　Push{fp};(str fp,[sp,#-4]!)
以下、略

### １－３：機械語に飛び込む
演習。用意されたサンプルファイルを用いて逆アセンブルを行う。




















## chap.2 ポインタとアセンブリ言語

## chap.3 ＣＰＵがプログラムを実行する仕組み

## chap.4 BIOSの仕組みと実機起動
