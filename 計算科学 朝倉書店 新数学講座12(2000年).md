計算科学　朝倉書店　新数学講座12(2000年).md

本書では、
コンピュータがどのように計算するか、どのように判断するかという原理を具体的に述べ、
暗号のために必要な大きな自然数の素因子分解や、数式処理のときに必要な多項式の素因子分解、
およびネットワークのときに必要なコード理論の数学的原理を書いている。
コンピュータと数学の接点として大切なグレブナー基底について基本的な部分にも触れた。

# 第１章　数の表し表し方　／　２進法。演算回路向を作るときに必要な事柄
節01　２進法
2^10=1024は一千に近いため、Ｋという単位がよく使われる。
問.01.01　十進法表示の整数987を２進法表示に改めよ。
問.01.02　２進法表示の整数1100110011を10進法表示に改めよ。
節02　２の補数表示
節03　算術シフト
ガウス記号　実数αに対し、　n<=α<n+1　となる整数nを[a]と表す。
節04　合同式
２の補数表示で表された２つの数を、足したり引いたりするには？
節05　
節06　

# 第２章　機械語　／　７つの命令。プログラム内蔵方式について
節07　アセンブリ命令
単純なコンピュータを仮に考える。
メモリは8192語（１語１６ビット）がある。2^10=1024、2^13＝8192。
演算装置がある。
演算装置で計算した結果を記録する16ビットのアキュムレータ（Acc）がある。

さて、計算はAccで行われるため、まず番地Ｍの内容16ビットをそのままAccにコピーが必要。
load M と命令しよう。逆に計算結果をAccから番地Ｍに写すにはStore Mと命令だ。
Accの内容に番地Ｍの内容を加えたものをAccに入れるにはAdd Mだ。
引くにはSubstractで。

では、Ａ番地の内容を16倍してその結果をＡに入れるにはどうすればよいか考えよう。

load A
add A
(合計１６回となるようにくり返し)
add A
store A
stop

これでもいいが。次のようにも行える。

Load A　…　x
add A　　…　2x
store A
add A　…　4x
store A
add A　…　8x
store A
add A　…　16x
store A
stop

次に、Ａ番地の内容とＢ番地の内容を交換するにはどうすればよいか考えよう。
Ａ番地の内容をx、Ｂ番地の内容をyとしよう。（A,B、Acc）＝(x,y,0)だ

プログラム５
load A …　AccはＡ番地の値を読み取る　(x,y,0→x)
store B　…　Accは自身の値を番地Ｂに置く　(x,y→x,x)
load B　…　AccはＢ番地の値を読み取る　(x,x,x→x)
store A　…　Accは自身の値を番地Ａに置く　(x→x,x,x)
stop

↑これは失敗である。番地Ｃも使って正しいやり方を書く。番地Ｃの内容はzとする。

プログラム６
load A …　AccはＡ番地の値を読み取る　(x,y,z,0→x)
store C …　Accは自身の値を番地Ｃに置く　(x,y,z→x,x)
load B　…　Accは番地Ｂの値を読み取る　(x,y,x,x→y)
store Ａ …　Accは自身の値を番地Ａに置く　(x→y,y,x,y)
load Ｃ　…　Accは番地Ｃの値を読み取る　(y,y,x,y→x)
store Ｂ …　Accは自身の値を番地Ｂに置く　(y,y→x,x,x)
stop　(y,x,x,x)

これで（A、B＝ｙ、ｘ）となった。

問7.3　Ａ←Ｂ←Ｃ←Ａ、つまり３つの値を入れ替えるプログラムを作れ。

少し技巧的だが、次のプログラム７は番地Ｃを使わずＡＢ入れ替えを行う。

プログラム７　（A,B、Acc）＝(x,y,0)とする
Load Ｂ …　AccはB番地の値を読み取る　(x,y,0→y)
Substract A …　Accは自身の値から番地Ａの値を引く　(x,y,y-x)
store B …　Accは自身の値を番地Ｂに置く　(x,y→y-x,y-x)
add A …　Accは自身の値に番地Ａの値を足す　(x,y-x,(y-x)+x=y)
store A …　Accは自身の値を番地Ａに置く　(x→y,y-x,y)
substruct B …　Accは自身の値から番地Ｂの値を引く　(x→y,y-x,y-（y-x）＝x)
store B …　Accは自身の値を番地Bに置く　(y,y-x→x,x)
stop　(y,x,x)


プログラム８は、Ａ番地の内容の絶対値を番地Ｂに入れる（Ｂ←｜Ａ｜）
jump minus M という命令は、アキュミュレが負のとき、
つまり符号ビットが１のとき、プログラム行の先頭BにＭと書かれた行を飛ぶ。
アキュミュレが正のとき、つまり符号ビットが0のとき、次の命令に進む。
jump Mという命令は、無条件でＭへ飛ぶ。

load A …　Accは番地Ａの値を読みとる。　Accの値は-5
jump minus M …　Accの値がマイナスならラベルＭへ飛ぶ
N:store B …　
stop
M:load Zero …　Accは番地Zeroの値を読む。　Accの値は0に
substruct A …　Accは自身の値に番地Ａの値を引く　Accの値は５に
jump N …　ラベル：Ｎの行は「store B」。これを実行するとAccは自身の値を番地Ｂに。５（番地Ｂに「-5」の絶対値が置かれた）
A -5
B 8
Zero 0

もし、Aが「５」なら、番地Ｂは５となり、番地Ｂに「5」の絶対値が置かれたことになる。

（菊地メモ：足し算命令だけでなく引き算命令がある理由を初めて理解した）

節08　乗法と除法

ふつうのコンピュータはアセンブリ命令の中に乗法や除法を行う命令がある。
しかし、ここで仮に考えられているコンピュータには先にあげた７つの命令のみであるため、
その７つを組み合わせて実現させよう。

乗法
Ａ番地の内容が正の整数x、Ｂ番地が正の整数ｙとする。また、x,y<2^15とする。
xとyをかけることを、xにxをy-1回加える、と置き換える。
y-1回加えたか否かの判定は、番地Ｂにy-2を入れ、１つずつ引き、負になったところで止める。

start:
load A …　Accは番地Ａの値を読みこむ　Acc=x
store C　…　Accは自身の値を番地Ｃに置く。　Ｃは-1からxに
load B　…　Accは番地Ｂの値を読みこむ　Acc=y
substract Two　…　Accは自身の値に番地Twoの値を引く　Acc＝y－２
store B　…　Accは自身の値を番地Ｂに置く。　Ｂはy－２

M:
load B　…　Accはy-2に　／　
jump minus End　…　
load C　…　Acc＝-1　／　
add A　…　Acc＝-1+x＝x-1
store C　…　Ｃはx-1に
load B　…　Accはy-2に
substract  One　…　Accはy-3に
store B　…　Ｂはy-3に
jump M　…　Ｍへ１回目

End:
stop

One 1
Two 2
A x
B y
C -1
　



節09　ユの互除法
節10　プ内蔵方式
節11　添え字のあつかい
節12　サブルーチン
節13　制御装置

# 第３章　論理回路　／　すべて電磁石のみを使って説明
節14　
節15　
節16　
節17　
節18　
節19　
# 第４章　コンピュータの模型　／　パルスに合わせてコンピュータがどのように命令を実行し、判断を行うか
節20　
節21　
節22　
# 第５章　素因子分解と暗号　／　大きな数の素因数分解をどのようにして行うか
節23　　
節24　
節25　
節26　
節27　
節28　
節29　
節30　
節31　
節32　
節33　
節34　
節35　
# 第６章　多項式の素因子分解　／　整数係数の多項式の素因子分解をコンピュータがいかに自動処理するか
節36　
節37　
節38　
節39　
節40　
節41　
節42　
# 第７章　符号理論　／　誤り訂正符号について。通信網に雑音があっても、少し余裕を込めて情報を送れば復元できる
節43　
節44　
節45　
節46　
# 第８章　グレブナー基底　／　ある集合の中に最小値があるということと、それを求めることとは、まったく別のことである。ユークリッド互除法のようなアルゴリズム
節47　
節48　
節50　
# 付録　平方剰余の相互法則
節Ａ　アイゼンシュタインの判定法
節Ｂ　ガウスの和
節Ｃ　相互法則の証明











